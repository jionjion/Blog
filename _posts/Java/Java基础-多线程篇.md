---
title: Java基础-多线程篇
categories:
  - Java
  - Thread
tags:
  - Java
  - Thread
abbrlink: cce7e955
date: 2022-08-15 05:24:51
---

> 介绍多线程、锁的使用与案例

<!-- more -->



# 线程池
为每个任务单独从池子中获取线程, 具有高效和快速..
避免了系统层面创建大量线程的开销问题



## 好处

1. 加快响应速度
2. 合理利用CPU和内存
3. 方便管理



## 使用

## 创建线程池
### 构造参数
| 参数            | 类型                       | 含义                                                         |
| --------------- | -------------------------- | ------------------------------------------------------------ |
| `corePoolSize`  | `int`                      | 核心线程数, 在线程池初始化完成后,默认没有线程,等任务到来后,再去创建线程,常驻的线程数量 |
| `maxPoolSize`   | `int`                      | 最大线程数, 在核心线程数基础上, 额外添加一些线程的数量上线   |
| `keepAliveTime` | `long`                     | 保持存活时间, 在线程多余核心线程数量且线程空闲时间超过存活时间, 则回收空闲线程 |
| `workQueue`     | `BlockingQueue`            | 任务存储队列                                                 |
| `threadFactory` | `ThreadFactory`            | 当线程池需要新的线程的时候, 会使用 `ThreadFactory` 来生成新的线程. 默认使用 `Executors.defaultThreadFactory()` 创建, 具有相同线程组和优先级 |
| `Handler`       | `RejectedExecutionHandler` | 由于线程池无法接受你所提交的任务的拒绝策略                   |



### 添加规则

1. 如果线程数小于 `corePoolSize`，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。
2. 如果线程数等于(或大于)  `corePoolSize` 但少于 `maximumPoolSize`，则将任务放入队列。
3. 如果队列数已满，并且线程数小于`maxPoolSize`，则创建一个新线程来运行任务。
4. 如果队列数已满，并且线程数大于或等于`maxPoolSize` ,则拒绝该任务。

#### 特点

1. 通过设置 `corePoolSize` 和 `maximumPoolSize` 相同，就可以创建固定大小的线程池。
2. 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。
3. 通过设置 `maximumPoolSize` 为很高的值，例如 `Integer.MAX_VALUE`，可以允许线程池容纳任意数量的并发任务。
4. 只有在队列填满时才创建多于 `corePoolSize` 的线程，所以如果你使用的是无界队列（例如 `LinkedBlockingQueue` )，那么线程数就不会超过 `corePoolSize`。

#### 工作队列
`SynchronousQueue`
直接交接队列, 没有容量, 在收到任务后直接交给线程执行,不会在队列停留

`LinkedBlockingQueue`
无界队列, 容量无限, 将所有的任务都放到队列中..如果处理的慢,可能会内存溢出

`ArrayBlockingQueue`
有界队列, 可以设置队列大小.

`DelayedWorkQueue`
延迟队列, 可以延迟工作



### 自动常用线程池构建

`newSingleThreadExecutor`
核心线程数量与最先线程数量均为1, 无存活时间, 队列使用 `LinkedBlockingQueue` 数量无限, 当队列积压过多时, 容易内存溢出.

`newFixedThreadPool`
线程固定数量,核心线程数与最大线程数一致, 无存活时间, 队列使用 `LinkedBlockingQueue` 数量无限, 当队列积压过多时, 容易内存溢出.

`newCachedThreadPool`
核心线程数为0, 最大线程数为 `Integer.MAX_VALUE`, 默认存活时间60S, 队列使用 `SynchronousQueue` 直接将任务交给线程, 当任务到来时, 直接创建新的线程完成任务, 超时自动回收多余线程.. 可能为会创建非常多的线程

`newScheduledThreadPool`
设置核心线程后, 最大线程数为 `Integer.MAX_VALUE`, 无存活时间, 具有延时或者周期性任务的线程池.. 



### 手动创建建议

CPU 密集型任务(加密, 计算), 最佳线程数为 CPU 核心线程数的 1-2 倍
耗时IO任务(数据库, 文件, 服务请求), 线程可以多点, 以 JVM 线程监控显示为依据.

线程数 = CPU 核心数 X (1 + 平均等待时间/平均工作时间)



### 停止线程池

| 命令               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| `shutdown`         | 初始化关闭,等线程和队列中的任务完成后再关闭                  |
| `isShutdown`       | 判断当前线程池是否在停止状态                                 |
| `isTerminated`     | 线程是否完全关闭                                             |
| `awaitTermination` | 等待一段时间, 如果当前10秒后还未关闭, 返回 False             |
| `shutdownNow`      | 立刻关闭线程池. 并将未执行的线程任务返回.. 如果线程被中断了, 抛出 `java.lang.InterruptedException` 异常 |



### 线程拒绝策略

`AbortPolicy`   拒绝任务时, 抛出异常
`DiscardPolicy` 拒绝任务, 且没有任何提示
`DiscardOldestPolicy` 丢掉最老的任务, 腾出空间给新任务
`CallerRunsPolicy` 将多余的线程,向上抛给提交线程去执行 



### 钩子函数

通过锁, 对线程进行等待和唤醒



### 线程池组成

- 线程池管理器  管理线程的类
- 工作线程      生成的任务线程对象
- 任务队列    队列的类
- 任务接口    具体的任务类



### 常见类关系

`Executor` 
顶级接口,定义 `execute` 执行方法

`ExecutorService`
继承自 `Executor` 接口, 并扩展提供 `shutdown`, `shutdownNow` 等线程管理方法

`ThreadPoolExecutor`
线程池, 具体的实现类, 实现上述接口

`Executors`
工具类,快速创建线程池



### 线程池状态

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| `RUNNING`    | 接受新任务并处理排队任务                                     |
| `SHUTDOWN`   | 不接受新任务, 但处理排队任务                                 |
| `STOP`       | 不接受新任务, 也不处理排队任务, 并中断正在进行的任务         |
| `TIDYING`    | 中文是整洁, 理解了中文就容易理解这个状态了: 所有任务都已终止, `workerCount` 为零时, 线程会转换到 `TIDYING` 状态, 并将运行`terminate()` 钩子方法。 |
| `TERMINATED` | `terminate()` 方法运行完成                                   |



## 适用场景

1. 服务器线程池
2. 需要多个线程处理任务



# `ThreadLocal` 介绍

## 使用场景
1. 每个线程需要一个独享的对象,通常是一个静态工具类..如 `Random` 类, `SimpleDateFormat` 类
2. 每个线程需要保存全局变量(如拦截器中获取用户信息), 让不同方法中直接使用, 避免参数传递的麻烦



### 每个线程需要独立副本

通过将静态成员变量, 放入到 `ThreadLocal` 中进行包装. 在每个线程使用时, 获取线程对应的静态成员变量, 避免多个线程间共用同一个对象



### 每个线程保存全局变量

将当前线程中共有的变量, 通过 `ThreadLocal` 中通过 `set/get` 进行存放



## 原理类

| 接口类           | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| `Thread`         | 线程, 每个线程中有成员变量 `threadLocals`, 存放一个 `Map`, 为 `ThreadLocalMap` 对象 |
| `ThreadLocalMap` | `Map` 结构, 持有 `ThreadLocal` 对象, 因为一个线程中, 可能关联有多个 `ThreadLocal` |
| `ThreadLocal`    | 具体的线程对应的变量相绑定                                   |



## 常用方法

- **`T setInitialValue()`**

1. 返回当前线程的初始值. 懒加载, 只有在 `get` 时才会执行
2. 当线程第一次使用 `get` 方法时, 将调用; 如果在此之前, 先调用了 `set` 方法, 则该 `setInitialValue` 方法不会被执行
3. 通常, 每个线程最多调用一次此方法, 但是如果已经调用了 `remove` 后, 再次 `get` 时, 会再次调用此方法
4. 如果不重写此方法, 则方法会返回 `null` , 一般我们会在创建阶段完成初始化.

- **`void set(T)`**
  为线程设置一个新值

- **`T get()`**
  得到线程对应的 `value` , 如果首次调用, 会执行 `initialValue` 方法
  `get` 方法是先取出当前线程的 `ThreadLocalMap`, 然后调用 `map.getEntry` 方法, 把本 `ThreadLocal` 的引用作为参数传入，取出 `map` 中属于本 `ThreadLocal` 的 `value`
  **注意，这个 `map` 以及 `map` 中的 `key` 和 `value` 都是保存在线程中的，而不是保存在 `ThreadLocal` 中**

- **`void remove()`**
  删除当前线程对应的值



## Value 内存泄露问题

`ThreadLocalMap` 的每个 `Entry` 都是一个对 `key` 的弱引用; 同时, 每个 `Entry` 都包含了一个对 `value` 的强引用
正常情况下, 当线程终止, 保存在 `ThreadLocal` 里的 `value` 会被垃圾回收, 因为没有任何强引用了
但是, 如果线程不终止(比如线程需要保持很久), 那么 `key` 对应的 `value` 就不能被回收, 因为有以下的调用链:
`Thread —> ThreadLocalMap —> Entry(key为null) -> Value`

因为 `value` 和 `Thread` 之间还存在这个强引用链路, 所以导致 `value` 无法回收, 就可能会出现 OOM
JDK已经考虑到了这个问题, 所以在 `set`, `remove`, `rehash` 方法中会扫描 `key` 为 `null` 的 `Entry`, 并把对应的 `value` 设置为 `null`, 这样 `value` 对象就可以被回收;
但是如果一个 `ThreadLocal` 不被使用, 那么实际上 `set`, `remove`, `rehash` 方法也不会被调用. 如果同时线程又不停止, 那么调用链就一直存在, 导致了value的内存泄漏

我们主动调用 `remove` 方法, 避免内存泄露



## 常用类

`RequestContextHolder`  Spring中存放http请求与响应的工具类



# 锁
## Lock 接口
锁是一种工具, 用于控制共享资源的访问 常用如 `ReentrantLock` 

### synchronized 

1. 效率低, 释放情况少(1.代码完全执行完成;2.抛出异常)
2. 获得锁的动作不能设定超时
3. 无法知道是否成功获得锁, 在尚未获取锁之前会一直等待...

### Lock 接口

`lock`                      获取锁, 如果当前锁已经被其他线程获取, 则等待; `Lock` 不会像 `synchronized` 那样在发生异常时解锁, 因此一定要在 `finally` 中释放
`tryLock`                   尝试获取锁, 可以设置超时时间, 如果依然没有拿到锁, 返回 false!
`lockInterruptibly`         相当于在尝试获取锁时将超时时间设置为无线,在等待锁的过程中, 可以被打断,抛出 `InterruptedException` 异常
`unlock`                    解锁, 一定要写在 finally 语句中, 千万不要忘记释放锁



## 标准用法

标准写法,在锁后必须跟上try执行业务逻辑和finally释放锁
```java
// 上锁
lock.lock();
// try 需要被独占的资源
try {
    System.out.println("业务逻辑.....");
} finally {
    // 必须释放锁 
    lock.unlock();
}
```



## 可见性

线程与线程之间数据的状态,保证不同线程之间可以看到对方的数据发生修改

> happens-before 原则: 我们这件事发生了, 别的线程能看到发生的事件, 知晓修改的内容;

`Lock` 和 `synchronized` 具有相同语义, 可以保证下一个线程在加锁后可以看到所有前一个线程解锁前发生的所有操作. 



## 锁的分类

| 说明                               | 锁                                              | 示例       |
| ---------------------------------- | ----------------------------------------------- | ---------- |
| 线程要不要锁住同步资源             | 锁住/悲观锁                                     | for update |
| 多线程能否共享一把锁               | 共享锁/独占锁                                   | 读写锁     |
| 多线程竞争时，是否排队             | 排队公平锁/非公平锁(先尝试插队，插队失败再排队) |            |
| 同一个线程是否可以重复获取同一把锁 | 可以可重入/不可重入锁                           |            |
| 可以可中断锁                       | 可中断锁/非可中断锁                             |            |
| 等锁的过程                         | 自旋锁(自旋,尝试获取锁)/非自旋锁(阻塞)          |            |



## 乐观锁与悲观锁

非互斥同步锁/互斥同步锁

### 悲观锁/互斥同步锁
在执行阶段,对资源进行锁定,等完成操作后再释放;避免多个线程间同时操作 
`synchronized` 关键字和 `Lock` 相关的各种类



悲观锁的缺点

1. 阻塞和唤醒带来性能问题
2. 可能陷入永久阻塞
3. 优先级低的线程拿到锁后会影响优先级错乱 



适合并发写入多的情况,临界区持锁时间长的情况,悲观锁可以避免大量无用的自旋消耗,典型情况有
- 临界区内有 `IO` 操作
- 临界区代码复杂, 循环多
- 临界区内竞争激烈



### 乐观锁/非互斥同步锁

在执行的时候不会发生锁,之后在最后更新阶段,会判断在此期间是否发生修改,未被修改则会更新;否则就丢弃/重试/报错..
原子类和并发容器.. 

> CAS算法, 在一个原子操作内完成对比和操作

适合并发写入少的情况,大部分情况是读取的场景,无需加锁就可以提高性能



## 可重入锁

`ReentrantLock` 可重入锁, 当前线程拿到锁后, 无需再次获取锁就可以持有, 线程可以多次获得同一把锁;
如, 在A方法中, 拿到锁后, 继续执行; 在B方法中, 需要同一个锁..由于已经获得当前锁,所以可以继续持有继续使用, 无需重复再次排队获取锁; 

- 避免了因为多次尝试获取同一把锁导致的线程死锁
- 同时提高的代码的封装



### 常用方法

`isHeldByCurrentThread`  当前线程是否被当前线程持有
`getQueueLength` 等待当前锁的队列有多长
`getHoldCount` 当前锁已经被拿了几次




## 公平锁/非公平锁
- 公平: 按照线程请求的顺序, 来分配锁
- 非公平: 不完全按照请求的顺序, 在一定情况下, 可以插队(一般是短时任务,在唤醒期间可以执行) 这样可以避免唤醒带来的空档期



`ReentrantLock` 默认创建时,构造参数可以确定, 默认不公平锁, `true` 为公平锁; `false` 非公平锁

`tryLock()` 方法,自带插队属性,如果尝试获取拿到了锁, 就可以插队执行



### 优势比较

|          | 优势                                                     | 劣势                                                         |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 公平锁   | 各线程公平平等，每个线程在等待一段时间后，总有执行的机会 | 更慢，吞吐量更小                                             |
| 非公平锁 | 更快，吞吐量更大                                         | 有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行 |



## 共享锁和排它锁
- 排它锁: 独占锁/独享锁, 在锁后只能当前线程进行操作
- 共享锁: 读锁, 无法修改和删除数据库,只能查看

`ReentrantReadWriteLock` 读写锁.读的时候,不上锁; 写的时候,上锁



### 共享规则

- 多个线程只申请读锁，都可以申请到
- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
- 如果有一个线程已经占用了写钞 员，则此时其他线程如果申请写锁或 者读锁，则申请的线程会一直等待释放写锁。
- 一句话总结:要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出丑(要么多读，要多一写)



### 读写锁的规则

读写锁只是一把锁，可以通过两种方式锁定: 读锁定和写锁定(多读一写)
读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定
但是永远不能同时对这把锁进行读锁定和写锁定

#### 排队策略
- 公平锁: 不许用插队
- 非公平: 
  - 写锁可以插队, 跑到读锁前面
  - 读锁仅在等待队列头节不是想要获取写锁的线程的时候可以插队

#### 锁的降级
`ReentrantReadWriteLock` 只支持降级, 不支持升级(避免死锁)
适合读多写少的情况, 进一步提高并发效率



## 自旋和阻塞锁

阻塞或者唤醒一个线程需要操作系统切换CPU状态来完成, 这种状态的转换需要消耗处理器时间..

如果同步代码块中的内容过于简单, 状态转换消耗的时间有可能比用户代码执行的时间还要长
在许多场景中, 同步资源的锁定时间很短, 为了这一小段时间去切换线程, 线程挂起和恢复现场的花费可能会让系统得不偿失

如果物理机器有多个处理器, 能够让两个或以上的线程同时并行执行, 我们就可以让后面那个请求锁的线程不放弃CPU的执行时间, 看看持有锁的线程是否很快就会释放锁 而为了让当前线程 "稍等一下", 我们需让当前线程进行自旋, 如果在自旋完成后前面锁定同步资源的线程已经释放了锁, 那么当前线程就可以不必阻塞而是直接获取同步资源, 从而避免切换线程的开销

阻塞锁和自旋锁相反, 阻塞锁如果遇到没拿到锁的情况, 会直接把线程阻塞, 直到被唤醒

默认的并发框架 `java.util.concurrent.atmoic` 包通过自旋实现

### 适用场景
自旋锁一般用于多核的服务器, 在并发度不是特别高的情况下, 比阻塞锁的效率高
另外, 自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后 才会释放），那也是不合适的



## 可中断锁

如果某一线程A正在执行锁中的代码, 另一线程B正在等待获取该锁可能由于等待时间过长, 线程B不想等待了, 想先处理其他事情, 我们可以中断它, 这种就是可中断锁

- `synchronized` 就不是可中断锁，
- `Lock` 接口及实现是可中断锁, `tryLock(time)` 和 `lockInterrupiptibly` 都能响应中断



## 虚拟机对锁的优化

### 虚拟机优化

#### 自旋锁和自适应
如果自旋锁的时间过长,自动转为阻塞锁

#### 消除锁
如果不需要加锁的地方,自动取消锁

#### 锁粗化
一系列重复的加锁解锁进行整体优化, 统一粗化

### 代码规范

1. 缩小同步代码块
2. 不要锁住方法, 而是锁住具体的执行逻辑
3. 减少请求锁的次数
4. 锁中不要再包含锁
5. 选择合适的锁类型或者合适的工具类



# `Atomic` 原子类
不可分割, 不可中断的最小操作原子




## JDK原子包
`java.util.concurrent.atomic.*` 原子类.
保证并发情况的线程安全
- 原子变量可以把竞争范围缩小到变量级别
- 比锁性能较高, 除了高度竞争的情况



## 原子类介绍

### `Atomic*` 基本类型原子类
保证基本数据类型,在多线程操作下的安全性
`AtomicInteger`
`AtomicLong`
`AtomicBoolean`



### `Atomic*Array`  数组类型原子类
保证数组内的数据类型, 在多线程操作的情况下的线程安全
`AtomicIntegerArray`
`AtomicLongArray`
`AtomicReferenceArray`



### `Atomic*Reference` 引用类型原子类
让一个对象保证操作的原子行...
`AtomicReference`
`AtomicStampedReference`
`AtomicMarkableReference`



### `Atomic*FieldUpdater` 升级类型原子类
适用大部分情况作为普通类使用, 只是偶尔原子操作... 
`AtomicIntegerFieldUpdater`
`AtomicLongFieldUpdater`
`AtomicReferenceFieldUpdater`



### 累加器

#### `Adder` 累加器
`LongAdder` 
`DoubleAdder`



#### `Accumulator` 累加器
`LongAccumulator`
`DoubleAccumulator`



#### 累加器比较

`LongAdder` 比 `AtomicLong` 效率高, 本质是空间换时间.. 
原理: 每个线程有自己的计数器, 只在汇总阶段进行, 竞争激烈的时候, `LongAdder` 会把不同线程对应放到不同的 call 上执行修改,降低了 flush 和 refresh 的时间 利用多段锁, 提高了并发性,
适合场景是统计求和和计数

`Accumulator` 更通用,支持函数表达式 更适合并行计算,多线程计算..



## CAS 原理

当且仅当内存值与预期值一致时, 才进行修改, 并返回内存的值..


乐观锁原理....
我认为它应该是A, 如果是的话我就改成B, 
如果不是A, 那我就不管了.避免多人修改的时候的出错

### 应用场景
- 乐观锁
- 数据库版本号
- 并发容器的自旋
- 原子类

`AtomicInteger` 原子类原理
加载 `Unsafe` 工具，首先获得内存地址(Unsafe工具来实现底层操作)
用 `volatile` 修饰 `value` 字段，保证线程间可见性
在 `do-while` 循环中, 完成原子性的比较和替换. 调用 `native` 本地方法



## 不变性

对象创建后, 状态不能被修改

### 使用
`final` 修饰的基本变量,值不能被改变;
如果是变量, 那么变量的引用不能变, 但引用的内容融然可以变;
属性被声明后, 只能被赋值一次

实例属性;
- 声明时等号右边
- 构造函数
- 初始代码块中

类属性:
- 声明时等号右边
- 静态代码快中

方法变量:
- 不规定赋值时机,但是必须在使用前赋值

`final` 修饰方法

- 不能被重写
- 不能修饰构造方法

`final` 修饰类
- 不可以被继承



## 线程安全

栈封闭
在方法内新建局部变量,每个栈空间不被其他变量访问,因此是线程安全的



# 并发容器
`ConcurrentHashMap` 线程安全的 `HashMap`
`CopyOnWriteArrayList` 线程安全的 `List`
`BlockingQueue` 这是一个接口, 表示阻塞队列, 非常适合用于作为数据共享的通道
`ConcurrentLinkeQueue` 高效的非阻塞并发队列, 使用链表实现. 可以看做一个线程安全的 `LinkedList`
`ConcurrentSkipListMap` 是一个 `Map`, 使用跳表的数据结构进行快速查找



## 分类
`Concurrent*` 大部分通过 CSA算法(比较并且交换) 实现
`CopyOnWrite*` 通过复制一份源数据实现
`Blocking*`  通过 AQS算法(抽象同步队列) 实现



## 古老的线程安全
`Vector` 和 `Hashtable`
古老的线程安全类, 其内部的方法被 `synchronized` 修饰, 以此保证多线程场景下, 只能有一个线程对容器进行修改

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
```



### 包装升级

通过 `Collection.synchronizedList` 和 `Collection.synchronizedMap` 进行升级,升级后返回一个新的子类
子类其内部方法通过 `synchronized(Object)` 使用同步代码块进行包裹, 保证线程安全

```java
public boolean add(E e) {
    synchronized (mutex) {return c.add(e);}
}
```



## `HashMap`

可以使用 `Collection.synchronizedMap(new HashMap()` 进行升级
迭代时不允许修改内容
读取时,线程安全, 写入时线程不安全
- 同时 put 碰撞时, 如果计算哈希值相同, 会碰撞丢失
- 同时 put 扩容时, 内部采用数组方式扩容, 旧的数组内元素会丢失
- `JDK1.7` 同时多线程扩容时, 会出现循环链表, 导致CPU溢出



## `ConcurrentHashMap`

线程安全的 `HashMap` 容器.
只能保证单个操作线程安全..(同时 put 不会数据错误; 但是多个线程间分别读取,计算, 赋值, 不能保证结果的安全)



### 原理
在 `HashMap` 中通过链表 + 红黑树, 在同一个 `node` 节点发生冲突次数+8时, 结构从链表转为红黑树..
可能出现线程安全的地方在有哈希冲突的 node 节点, 因此..对node节点的操作, 采用 CAS 自旋比较替换 或者 synchronized 包裹最小代码单元完成线程间的统一



## `CopyOnWriteArrayList`

代替 `Vector` 和 `SynchronizedList` ,降低锁的粒度
类似的还有 `CopyOnWriteArraySet` 代替 `Set`

### 适用场景
- 读操作要尽可能快, 而写即使慢一点也没有关系
  - 黑名单, 每日更新, 监听器等.. 

### 读写锁分离
读写锁升级; 读取的时候不加锁, 只写也不会阻塞读取操作.. 只有在写入之间才会加锁

### 原理
创建新的副本, 读写分离..
写的时候, 拷贝一份新的数据, 完成后, 修改原有容器的指向, 即保证了读的时候不变, 又保证了写的时候线程安全..
迭代器使用的时候,使用的是不可变的旧数组数据...

### 问题
数据一致性: 只保证最后的数据一致, 不保证数据的实时一致, 因此在读和写的时候是两份数据, 会有出入
内存占用高: 采用赋值机制, 在进行写操作时, 内存中会有两份数据



## 并发队列

`Queue`: 保证一组等待被处理的数据
`BlockingQueue`: 添加了阻塞操作, 在队列为空或者队列满了后, 线程阻塞
`Deque`: 双端队列

### 阻塞队列
具有阻塞功能的队列.一端为生产者, 另一端为消费者, 由于队列本身具有线程安全性, 因此无需单独再做另外处理..

是否有界,  分为有界队列和无界队列(最大支持 `Integer.MAX_VALUE`)

队列是线程池的组要组件..

### 常用方法

| 方法                   | 说明                                         |
| ---------------------- | -------------------------------------------- |
| `take`                 | 移除头节点,如果为空时,阻塞                   |
| `put`                  | 添加尾节点,当队列满了,阻塞                   |
| `add, remove, element` | 添加, 删除, 返回元素,为空返回异常            |
| `off, poll, peek`      | 添加,取出,拿取(拿去后不删除), 并返回是否成功 |



### 分类

| 队列                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `ArrayBlockingQueue`    | 有界队列, 需要指定容量, 是否公平(如果保证公平, 那么等待最长时间的线程会被优先处理, 不过会带来一些性能损耗) |
| `LinkBlockingQueue`     | 无界队列                                                     |
| `PriorityBlockingQueue` | 无界队列<br/>支持优先级排序; <br/>自然排序, 放入的成员必须实现排序接口 |
| `SynchronousQueue`      | 队列容器是0, 无需等待直接交给消费者处理,直接交换, 效率很高<br/>没有对应的成员操作方法.. |
| `DelayQueue`            | 无界队列<br/>延迟队列, 根据延迟时间排序<br/>元素需要实现 `Delayed` 接口, 规定排序规则 |
| `ConcurrentLinkedQueue` | 非阻塞队列, 只有 `ConcurrentLinkedQueue` 一种, 内部使用链表作为数据结构, 使用 CAS(比较并且交换) 非阻塞算法实现线程安全..并发性能较高 |




### 选择顺序
1. 边界大小, 选择是否有边界
2. 空间大小, 如果非阻塞, 使用 `ConcurrentLinkedQueue`
3. 吞吐量 `LinkBlockingQueue` 优于 `ArrayBlockingQueue`
4. 是否需要交换, 直接交换使用 `SynchronousQueue`
5. 是否需要重要排序, 使用 `PriorityBlockingQueue`
6. 是否需要延时, 使用 `DelayQueue`



# 并发流程控制

## 并发任务控制器
默认系统自行控制, 也可以自行控制



| 类               | 用途                                                         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Semaphore`      | 信号量, 可以通过控制“许可证”的数量,来保证线程之间的配合      | 线程只有在拿到“许可证"后才能继续运行.相比于其他的同步器, 更灵活 |
| `CyclicBarrier`  | 线程会等待, 直到足够多线程达到了事先规定的数目, 一旦达到触发条件,就可以进行下一步的动作. | 适用于线程之间相互等待处理结果就绪的场景                     |
| `Phaser`         | 和 `CyclicBarrier` 类似, 但是的计数可变                      | Java 7加入                                                   |
| `CountDownLatch` | 和 `CyclicBarrier` 类似, 数量递减到0时, 触发动作             | 不可重复使用                                                 |
| `Exchanger`      | 让两个线程在合适时交换对象                                   | 适用当两个线程工作在同一个类的不同实例上时, 用于交换数据     |
| `Condition`      | 可以控制线程的 “等待” 和 "唤醒", 是 `Object.wait()` 的升级版 |                                                              |



## `CountDownLatch` 类
倒数门栓, 并发流程控制工具
例如: 拼团购物; 购票,人满发车..
流程: 倒数结束之前, 一直处于等待状态, 直到倒计时结束, 线程才继续工作

### 主要方法

| 方法                        | 说明                                                 |
| --------------------------- | ---------------------------------------------------- |
| `CountDownLatch(int count)` | 构造函数, `count`  为需要倒数的值                    |
| `await()`                   | 调用后线程会挂起, 直到 `count` 为 0 后才会继续执行   |
| `countDown()`               | 将 `count` 值减1, 当 `count` 为 0 时, 线程会被唤起.. |

### 适用场景

用法1: 一等多, 一个主线程等待多个线程执行完毕后, 再继续主线程的工作
用法2: 多等一, 多个线程等待一个线程的信号, 同时开始执行. 

注意:倒数门栓类不能重用,需要重新构建



## `Semaphore` 类
信号量, 限制或者管理有限的资源的使用情况

### 主要方法

| 方法                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `Semaphore(count, fair)`   | 初始化一个信号量, 并指定是否为公平锁(一般是TRUE,公平锁)      |
| `acquire()`                | 获取一个(或多个)线程许可, 未获取前阻塞, 可以被中断抛出异常... |
| `acquireUninterruptibly()` | 获取一个线程许可, 未获取前阻塞, 被中断不会抛出异常           |
| `tryAcquire()`             | 尝试获取线程许可, 否则继续执行                               |
| `tryAcquire(timeout)`      | 尝试在等待中, 获取许可证                                     |
| `release()`                | 将一个(或多个)许可证放回                                     |



## `Condition` 接口

条件接口, 用来代理 `await()` 和 `notify()` 方法

### 场景

当线程1需要等待某个条件的时候, 它就去执行
`condition.await()` 方法, 一旦执行了 `await()` 方法, 线程就会进入阻塞状态
然后通常会有另外一个线程, 假设是线程2, 去执行对应的条件, 直到这个条件达成的时候, 线程2就会去执行
`condition.signal()` 方法, 这时JVM就会从被阻塞的线程里找, 找到那些等待该 `condition` 的线程, 当线程1就会收到可执行信号的时候, 它的线程状态就会变成Runnable可执行状态

`signalAll()` 会唤起所有的正在等待的线程
但是 `signal()` 是公平的, 只会唤起那个等待时间最长的线程



## `CyclicBarrier` 循环栅栏
`CyclicBarrier` 循环栅栏和 `CountDownLatch` 很类似, 都能阻塞一组线程
当有大量线程相互配合, 分别计算不同任务, 并且需要最后统一汇总的时候, 我们可以使用 `CyclicBarrier`.
`CyclicBarrier` 可以构造一个集结点, 当某一个线程执行完毕, 它就会到集结点等待, 直到所有线程都到了集结点, 那么该栅栏就被撤销, 所有线程再统一出发, 继续执行剩下的任务.



### 区别
作用不同: `CyclicBarrier` 要等固定数量的线程都到达了栅栏位置才能继续执行, 而 `CountDownLatch` 只需等待数字到0, 也就是说, `CountDownLatch` 用于事件, 但是 `CyclicBarrier` 是用于线程的.

`CountDownLatch` 作用于一个一个事件, 具体的方法事件中,调用 `countDownLatch.await()`
`CyclicBarrier` 作用于线程, 线程调用 `cyclicBarrier.await()`

可重用性不同: `CountDownLatch` 在倒数到0后并触发门门打开后, 就不能再次使用了, 除非新建新的实例;
而 `CyclicBarrier` 可以重复使用.每次凑够后都可以执行..



# AQS

抽象队列同步器, 一个用于构建锁, 同步器, 线程协作工具类的基础工具类. 用来构jdk中`java.util.concurrent.*` 建基础的并发控制器

## 抽象类设计思路
内部实现 `Sync` 类, 继承自 `AbstractQueuedSynchronizer`, 并实现其中的部分方法, 扩展完成业务逻辑..
如 `Semaphore` 信号量, `CountDownLatch` 门栓类, `ReentrantLock` 可重入锁.内部均有一个 `Sync` 内部类, 继承自 `AbstractQueuedSynchronizer`
抽象了队列管理, 线程阻塞/解除的管理, 同步状态的原子性管理..



## 内部原理

### `state` 状态管理
被 `volatile` 修饰的 `int` 类型, 在不同子类中拥有不同的含义.
由于会被线程并发修改, 因此用 `compareAndSetState` 保证线程安装操作..

- `Semaphore` 信号量中代表许可证数量;
- `CountDownLatch` 门栓中代表倒数数量;
- `ReentrantLock` 代表可重入次数;

### `FIFO` 队列
先进先出的队列, 控制线程抢锁和配合.. 存放等待的线程..
内部类 `Node` 表示链表节点, 在类中维护了上一个节点,下一个节点的引用..

### 期望子类去实现的方法 
期望协作工具类去实现的获取/释放...等重要方法

方法依赖 `state` 变量, 决定是否阻塞..
`Semaphore` 信号量中,`acquire` 方法, 获取一个许可证, `state` 代表许可数量用尽为0, 线程阻塞 
`CountDownLatch` 倒数门栓中, `await` 方法, 当 `state` 代表倒计数量, 如果不为0, 表示正在倒数, 线程阻塞
`ReentrantLock` 中, `lock` 方法, 当前持重入锁次数不为0, 表示有其他线程持有锁, 

需要重写 `tryAcquire`, `tryAcquireShared` 获取方法, `tryRelease`, `tryReleaseShared` 释放锁方法..



## AQS 的用法

第一步, 写一个类, 想好协作的逻辑, 实现获取/释放方法
第二步, 内部写一个 `Sync` 类继承 `AbstractQueuedSynchronizer`
第三步, 根据是否独占来重写 `tryAcquire`/`tryRelease` 或 `tryAcquireShared`/`tryReleaseShared`方法
在之前写的获取/释放方法中调用AQS的 `acquire`/ `release` 或者 `shared` 方法

`unsafe.park` 本地方法, 将当前线程挂起 

### AQS在 `CountDownLatch` 的总结
调用 `CountDownLatch` 的 `await` 方法时, 便会尝试获取"共享锁", 不过一开始是获取不到该锁的, 于是线程被阻塞. 而"共享锁"可获取到的条件, 就是"锁计数器"的值为0. 
而"锁计数器"的初始值为count, 每当一个线程调用该 `CountDownLatch` 对象的 `countDown()` 方法时, 才将"锁计数器"-1
`count` 个线程调用 `countDown()` 之后, "锁计数器"才为0, 而前面提到的等待获取共享锁的线程才能继续运行. 

### AQS在 `Semaphore` 的应用
在 `Semaphore` 中, `state` 表示许可证的剩余数量. 
在 `tryAcquire` 方法中, 判断 `nonfairTryAcquireShared` 大于等于0的话, 代表成功
这里会先检查剩余许可证数量够不够这次需要的, 用减法来计算.
如果直接不够, 那就返回负数, 表示失败, 如果够了, 就用自旋加 `compareAndSetState` 来改变 `state` 状态, 直到改变成功就返回正数;或者是期间如果被其他人修改了导致剩余数量不够了, 那也返回负数代表获取失败

### AQS在` ReentrantLock` 的应用
释放锁的方法 `tryRelease`由于是可重入的, 所以 `state` 代表重入的次数
每次释放锁, 先判断是不是当前持有锁的线程释放的, 如果不是就抛异常, 如果是的话, 重入次数就减一, 如果减到了0, 就说明完全释放了, 于是 `free` 就是 `true`, 并且把 `state` 设置为0. 
加锁的方法

<hr/>



# 线程治理

继线程池之后, 又一个好用的线程管理工具..可以方便的管理线程间协作.

## `Runnable` 的缺陷
- 没有返回值
- 不能抛出检编译异常...

## `Callable` 接口
被其他线程执行任务, 通过实现实现 `call` 方法, 定义具体任务及返回值, 支持声明抛出的异常..



## `Future` 类

用 `Future.get` 来获取 `Callable` 接口返回的执行结果; 通过 `Future.isDone()` 来判断任务是否已经执行完了; 以及取消这个任务，限时获取任务的结果等
在 `call()` 未执行完毕之前, 调用 `get()` 的线程(假定此时是主线程)会被阻塞, 直到 `call()` 方法返回了结果后, 此时 `future.get()` 才会得到该结果, 然后主线程才会切换到 `runnable` 状态
所以 `Future` 是一个存储器, 它存储了 `call()` 这个任务的结果而这个任务的执行时间是无法提前确定的, 因为这完全取决于 `call()` 方法执行的情况

### 常用方法
#### `get()` 

获取线程的执行结果, 在结果获取前会处于阻塞状态

1. 任务整成完成, `get()` 方法会立即返回结果
2. 任务尚未完成, `get()` 方法会阻塞直到任务完成
3. 任务执行过程中发生异常, `get()` 方法会抛出包装异常 `ExecutionException` 
4. 任务被取消, `get()` 会抛出 `CancellationException`
5. 任务超时, `get()`会抛出 `TimeoutException`

#### `cancel()`

 取消任务执行

#### `isDone()` 

判断线程是否执行完毕; 注意并不是代表任务执行成功哦

#### `isCancelled()` 

是否被取消

1. 任务还未开始,取消返回 `ture`
2. 任务已经完成,取消返回 `false`
3. 任务正在执行, 不会直接取消任务. 而是根据方法的入参 `mayInterruptIfRunning` 作具体判断
`Future.cancel(false)` 仅用于避免启动尚未启动的任务, 适用于:
1.未能处理interrupt的任务
2.不清楚任务是否支持取消
3.需要等待已经开始的任务执行完成;
`Future.cancel(true)` 中断任务, 并掉用任务中的 `InterruptedException` 异常的方法


### 使用场景
首先, 我们要给线程池提交我们的任务, 提交时线程池会立刻返回给我们一个空的 `Future` 容器 当线程的任务一旦执行完毕
也就是当我们可以获取结果的时候, 线程池便会把该结果填入到之前给我们的那个 `Future` 中去 (而不是创建一个新的Future), 我们此时便可以从该 `Future` 中获得任务执行的结果

### 使用
1. 通过线程池, 使用 ` <T> Future<T> Executor.submit(Callable<T> task);`
2. 通过未来任务使用 `FutureTask.submit(Callable<T> task)`.. 
因为 `FutureTask` 类实现 `RunnableFuture<V> extends Runnable, Future<V>` , 同时具有执行线程和执行回调的能力..

### 注意点
- 如果批量执行, 其中最慢的线程导致 `get()` 时阻塞,可以
  1. 用 `timeout` 限制时间
  2. 使用 `CompletableFuture` 类, 先完成后先获取 
- `Future` 生命周期不可以后退
  1. 一旦完后成, 就停留在已完成阶段, 不能重头再来